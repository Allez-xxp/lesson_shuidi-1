let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// 一种错误的算法
// arr.sort(()=>Math.random() - 0.5); //伪随机
// 排序，传一个函数
// 这种其实没有达到真正的乱序的
// 考察有没有实现乱序是要求这10个位置，每个位置上出现的数组中的数字的概率要相同的
// 9出现在第一位的概率要是相同的，出现在第二位的概率是相同的...
// 一个乱序的算法，打乱数组，会得到一个新的数组，假设打乱1000次
// n次对于每一个位置求平均值，1000个第一位有个平均值，1000个第二位求平均值，每一位要达到平均值4.5，也就是比如9出现在每个位置上的概率相等
// 算每一位上的和，总和之后再除以次数
// 总和的初始值
// 验证一下
let sum = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function shuffle(arr){ //看一下是不是真的乱了
    // arr.sort(()=>Math.random() - 0.5); //注意，sort会修改原来的数组的数据的，我们的乱序算法是要对原来数组乱序！，每次乱序要对原始数组乱序，而不是新产生的乱序结果
    // 浅拷贝一下，用slice
    // 为什么sort就能实现乱序呢？
    // sort的回调，就是用来决定两个数是否要进行交换
    arr.sort(()=>Math.random() - 0.5); //注意，sort会修改原来的数组的数据的，我们的乱序算法是要对原来数组乱序！，每次乱序要对原始数组乱序，而不是新产生的乱序结果
    
    return arr;
}

let t = 10000;
for(let i = 0; i < t; i++) {
    // 乱序一次之后的结果
    // let sorted = shuffle(arr) 
    let sorted = shuffle(arr.slice(0)); //浅拷贝一下，让它每次都只对最原始的那个
    sorted.forEach((num, i)=> {
        sum[i] = num + sum[i]; //每一位上的和计算出来，求了之后保存在sum中
    });
}
// 所以因为sort倒是结果不是我们想要的,用slice浅拷贝，发现概率偏高偏低，这是sort排序的一个问题
// 发现出现了极端的例子，前面的很小，后面的很大
// 这跟sort有关，偏低是因为在前几个的值小，但是又出现了很多次，拉低了平均值，最后一个5点几，是因为后面的数很大，出现了最后面的概率又很大，所以会偏大
// 这就是数组中的每一个出现在每个位置上的概率不均等
console.log(sum.map(n => n/t));
// 交换的规则 这个我们每次的规则都是一定的，要么是a-b,要么是b-a,按照这个回调的规则
arr.sort((a, b) => a - b) //升序
arr.sort((a, b) => b - a) //降序
// sort
// a-b<0说明a> b
// a和b表示正在进行排序的两个数，
// 0 - 1 < 0 升序 a在b前面
// 1 - 0大于0,b排到a前面，也就是1排到0前面，就要进行交换顺序了 降序

// ()=>Math.random() - 0.5
// Math.random()是0-1之间的值 而0.5刚好是中间值，就以为着Math.random()-0.5有了两种情况
// 大于0或者小于0 每次判断要不要交换，然后因为是随机的，所以不能保证是不是一定要交换
// 可能Math.random()-0.5>0,也可能<0,也就是因为这里的不确定，这个不确定的规则就让我们的数组看着就是交换的很乱，达到乱序
// 简单的冒泡看看回调到底是在哪里生效的

// 一次冒泡只能决定一个数字的正确位置，两两相邻的相比较，比较过的就不管了，一次冒泡可以比较好i个数
let arr1 = [2,5,3,6,7];
function bubble(arr) {
    // 总的有几个数字就要冒几次泡
    for(let i = 0; i < arr.length; i++) {
        // 每次排序都是两个相邻的数往后进行比较着往后走
        // 比较时从0开始，到哪里结束？比较过的就不用再比了i次冒泡处理好i个数
        for(let j = 0; j < arr.length - i; j ++) {
            // 跟i+1比较(两个相邻的数进行比较)
            let k = j + 1; //j跟k比较
            // 我们的回调函数就在这里生效了，sort的回调，回调决定大于0（降序）还是小于0
            // 这里导致它的随机性存在问题
            if (arr[j] < arr[k]) { //降序
                [arr[k], arr[j]] = [arr[j], arr[k]] //传回调的参数
            }
        }
    }
    console.log(arr);
}
bubble(arr1);