链接：https://leetcode-cn.com/problems/the-masseuse-lcci
面试题17.16

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
动态规划：
求最优解问题，一般都可以想到使用动态规划（Dynamic Programming）来解决。
题解：
https://leetcode-cn.com/problems/the-masseuse-lcci/solution/javascriptdong-tai-gui-hua-fa-fu-xiang-jin-jie-du-/
动态规划有三个重要的概念：
最优子结构
边界
状态转移方程
let dp = new Array(Length).fill(undefined).map(ary => [0, 0]);
Array.prototype.fill()的参数是引用类型时,无论这个引用类型是如何生成的，数组中的元素都会指向同一个对象，故需要再利用Array.prototype.map()来返回一个新的数组，隔断引用。

let foo = new Array(2).fill([0]);
foo[0][0] = 1;
foo[0][0] === foo[1][0]; // true

最优子结构：
由于无法接受相邻的预约，所以，第i个预约的状态，取决于第i-1个预约是否接受：

第i个预约接受： 第i-1个预约必定不可以接受。
第i个预约不接受：第i-1个预约接受与否随意。
所以关键点在于，需要区分出“是否接受”这一状态。

边界：
由于无法接受相邻的预约，所以，第i个预约的状态，取决于第i-1个预约是否接受：

第i个预约接受： 第i-1个预约必定不可以接受。
第i个预约不接受：第i-1个预约接受与否随意。
所以关键点在于，需要区分出“是否接受”这一状态。

状态转移方程：
dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1])：如果第i个预约请求不接受，则它的总预约时长就应当取「第i-1个预约接受总时长」和「第i-1预约不接受总时长」之中的最大值。
dp[i][1] = dp[i - 1][0] + nums[i]：如果第i个预约请求接受，则它的总预约时长就直接是「第i-1个预约不接受的总时长」加上「第i个预约接受的时长」。
