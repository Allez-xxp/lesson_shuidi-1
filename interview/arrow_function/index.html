<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>函数的super</title>
</head>
<body>
    <!-- 箭头函数是没有this的，它的this是作用域查找才有的
    <script>
        //怎么构成父子关系，其中一种
        //父
        var obj1 = {
            sayHello() {  //方法名一样，父子的
                console.log('父类的hello');
            }
        }
        //子
        var obj2 = {
            sayHello() {  //方法名 父类的同名方法
                //调用父类的方法,有父子关系的，就能调用super
                super.sayHello(); 
                console.log('子类的hello');
            }
        }
        //es6里Object对象的新方法
        // 原型继承  构成父子关系
        Object.setPrototypeOf(obj2, obj1);  //其实就是将obj2的proto属性设置成为obj1
        obj2.sayHello();
    </script> -->
    
    <!-- 箭头函数 -->
    <!-- <script>
        var obj1 = {
            sayHello:()=> {  //方法名一样，父子的
                console.log('父类的hello');
            }
        }
        //子
        var obj2 = {
            sayHello:()=>{  //方法名 父类的同名方法
                //调用父类的方法,有父子关系的，就能调用super
                super.sayHello(); 
                console.log('子类的hello');
            }
        }
        //es6里Object对象的新方法
        // 原型继承  构成父子关系
        Object.setPrototypeOf(obj2, obj1);  //其实就是将obj2的
        obj2.sayHello();  //Uncaught SyntaxError: 'super' keyword unexpected here
    </script> -->

    <!-- es5的函数定义方式 -->
    <script>
        var obj1 = {
            sayHello:function(){  //方法名一样，父子的
                console.log('父类的hello');
            }
        }
        //子
        var obj2 = {
            sayHello:function(){  //方法名 父类的同名方法
                //调用父类的方法,有父子关系的，就能调用super
                super.sayHello(); 
                console.log('子类的hello');
            }
        }
        //es6里Object对象的新方法
        // 原型继承  构成父子关系
        Object.setPrototypeOf(obj2, obj1);  //其实就是将obj2的
        obj2.sayHello();  //不行，还是得用es6中的 二是es5中没有class关键字，所以没有super
    </script>
</body>
</html>