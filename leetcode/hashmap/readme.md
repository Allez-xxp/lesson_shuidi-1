1. 10万条，URL访问日志（Log）一万个用户，应用场景
备忘录算法
10万条URL 访问日志 按访问次数给URL排序
所以要输出一个URL，排好序的
/ 3万条
/detail/1221212 5k
/detail/5555 5k
/comments/12121 2.1k
['/','/detail/1221212','/detail/5555','/comments/12121']

1. 选择什么样的数据结构解决这个问题？
前端 JSON Object{ }-》 散列表（HashMap)  键值对 高级的数据结构 语言内置的
2. 算法实现这个数据结构
接触过什么样的排序算法？

1.首先要做一次for循环 遍历一次，有10万条url就是一个key,value 第一次就计为1，否则就加一
一个字典，一个hashmap,在不同语言中叫法不一样。
构建出：
{
    '/': 30000,
    '/detail/1221212':5000,
    ...
}
散列表，什么叫散...
2.排序 怎么排？
排完后得到一个['url']排好序的

Word 有项功能 单词纠错
错的单词下面会标红
将输入的单词与词典对比
建一个字典，在js中叫做json Object
把易混错的单词做成一个人key,为其纠错。
dictionary hashmap的时间复杂度是O(1),这就是我们选择这种数据结构的原因。
不需要遍历，只需要通过输入作为key去我们hashmap中找一下，就出来了

Hash Table 哈希表
为key:value的访问提供了一个O(1)的时间复杂度
两数相加
一次O(n)开销后，形成一个hash table
key：value

hash table的O(1)这种的访问在哪种更简单的数据结构中用过？
数组中
数组为什么可以实现O(1)的时间复杂度的访问？
散列表的概念
运动会，89个同学一起参与1000米跑步，记录成绩是用数组放置,每个同学身上贴一个参赛号码0..88
成绩：[13,11,12...]这里面就散开来了。
如果89个人全都聚在一起，想要快速区分某个人，用O(1)是不可能的
大家都散开来，数组就是一个散表，散开来后每个人就是一个坑位，也就是数组的下标，就能通过下标快速找到比如40号存在哪里，
时间复杂度是O(1),因为它不需要从第一个位置一直往后遍历n个位置，
O（1）  start(0)+40偏移量 算法物理执行的本质
内存地址的计算

散列表的概念  他也是散开来，他是列作为下标也就是key,
它的查询是O(1)

思考40号选手在数组中就是他的下标，下标是数值型的
hashmap中用key做下标
希望查出来的不仅是40号这个号码，还有关于选手的其他信息 这里面的key比单纯的数值更有意义
030340 加上班级号 表达出更多的含义
这样的话怎么实现O(1)呢？
hashmap是如何实现O(1)查询的？
运动会 030340号码（散列表的表示）  40号(数组的表示)  在各个跑道散开的运动员身上的号码，这两个在最后的跑道上的占位上其实是同一个概念
散开的
做一个列-》integer i 的散列处理函数
物理上 key->计算出一个物理位置O(1),把值返回

030340 如何反映出原来是40号位置？