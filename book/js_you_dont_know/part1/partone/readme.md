# 你不知道的javascript
## 第1章 作用域是什么 P4
需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。这套规则被称为作用域。在哪里会设置这些作用域的规则呢？
### 1.1 编译原理
尽管通常将javascript归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。与传统编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植。
在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。
- 分词/词法分析
  这个过程会将由字符组成的字符串分解成对编程语言来说有意义的代码块，这些代码块被称为词法单元（token）。例如：var a = 2;会被分解成：var、a、=、2、；。5部分。空格是否会被当做词法单元，取决于空格在这门语言中是否具有意义。
  分词和词法分析的区别主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。
- 解析/语法分析
  这个过程是将词法单元流数组转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”
- 代码生成
  将AST转换为可执行代码的过程被称为代码生成。
JavaScript引擎在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。
JavaScript引擎不会有大量的时间用来进行优化，因为JavaScript的编译过程不是发生在构建之前的。
JavaScript引擎大部分情况下编译发生在代码执行前的几微妙的时间内。
任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）。JavaScript编译器首先对程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。
### 1.2 理解作用域
#### 1.2.1 演员表
- 引擎
  从头到尾负责整个JavaScript程序的编译及执行过程。
- 编译器
  引擎的好朋友之一，负责语法分析及代码生成等脏活累活。
- 作用域
  引擎的另一个好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
#### 1.2.2 对话
对于var a = 2;引擎有两种不同的声明，一个由编译器在编译时处理，另一个由引擎在运行时处理。
变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。否则抛出异常。
#### 1.2.3 编译器有话说 P7
引擎为变量a进行LHS查询，进行RHS查询。是一个赋值操作的左侧和右侧。
RHS查询与简单的查找某个变量的值别无二致（得到某某某的值），LHS查询是试图找到变量的容器本身，从而可以对其赋值。
### 1.3 作用域嵌套
作用于是根据名称查找变量的一套规则。
### 1.4 异常
LHS和RHS是很重要的。
### 1.5 小结 P13
不成功的RHS会抛出异常，不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下）。

# 第2章 词法作用域
作用域有两种工作模式，词法作用域，动态作用域。
## 2.1 词法阶段 P14
大部分标准语言编辑器的第一个工作阶段叫做词法化（也叫单词化），词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程；还会赋予单词语义。
简单来说，词法作用域就是定义在词法阶段的作用域，由你在写代码时将变量和块作用域写在哪里来决定的。
- 查找
  作用域查找会在找到第一个匹配的标识符时停止。
## 2.2 欺骗词法
在运行时“修改”（也可以说欺骗）词法作用域，JavaScript中有两种机制来实现这个目的。
### 2.2.1 eval P17
eval()函数。
### 2.2.2 with

# 第三章 函数作用域和块作用域
## 3.1 函数中的作用域
对于标识符附属于其他作用域气泡的（foo(...)），不能从foo外部对他们进行访问问，也就是说这些标识符都无法从全局作用域中进行访问。
## 3.2 隐藏内部实现
把变量和函数包裹在一个函数的作用域中，然后用这个作用域来隐藏它们。
为什么有基于作用域的隐藏方法？他们大多都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。
- 规避冲突
隐藏作用域中的变量和函数所带来的另一个好处，是可以规避同名标识符之间的冲突，防止变量的值被意外覆盖。
1. 全局命名空间变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果他们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。
这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性。
2. 模块管理
## 3.3 函数作用域
包装函数的声明以(function...而不是以function...开始。函数会被当作函数表达式而不是一个标准的函数声明来处理。
### 3.3.1 匿名和具名
会调参数
setTimeout(function(){
    console.log("I waited 1 second!");
},1000);
这叫匿名函数表达式，因为function()...没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在JavaScript中这是非法的。
行内函数表达式——匿名具名之间的区别不会对这点有任何影响：
setTimeout(function timeoutHandler(){
    console.log("I waited 1 second!)";
},1000);
### 3.3.2 立即执行函数表达式 P28
var a=2;
(function foo(){
    var a=3;
    console.log(a);//3
})();
console.log(a);//2
由于函数被包含在一对（）括号内部，因此成为了一个表达式，通过在末尾加上另外一个（）可以立即执行这个函数。
(function(){...}())
(function(){...})()两种功能上一致
- IIFE还有一种用途是倒置代码的运行顺序，将需要运行的函数放在第二位。
## 3.4 块作用域
使用var声明变量，它始终是属于外部作用域的。
### 3.4.1 with
### 3.4.2 try/catch
try{
    undefined();//执行一个非法操作来强制制造一个异常
}
catch(err){
    console.log(err);//能够正常执行
}
console.log(err);//出错！err仅存在catch分句内部，当试图从别处引用它时会抛出错误。
### 3.4.3 let P32
显式地块作用域加{...}
1. 垃圾收集
2. let循环
### 3.4 4 const P36
const同样可以用来创建块作用域变量，但其值是固定的（常量）。之后试图修改值会引起错误。
## 3.5 小结
let用来在任意代码块中声明变量。
if(...){let a=2;}会声明一个劫持了if的{...}块变量，并且将变量添加到这个块中。

# 第四章 提升
函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。
## 4.1 先有鸡还是先有蛋
a=2;
var a;
console.log(a); //不会输出undefined,会输出2
没有按从上到下一行一行执行
console.log(a);
var a=2;//不会输2，会抛出undefined异常
是为什么呢？
## 4.2 编译器再度来袭
引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。
所以正确的思考思路：包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。
var a=2;
javascript会看成两个声明：var a; 和a=2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。所以两段代码的执行过程是：
- var a;
  a=2;
  console.log(a);
  其中第一部分是编译，第二部分是执行。
- var a;
  console.log(a);
  a=2;
因此打个比方，这个过程就好像变量和函数声明从他们在代码中出现的位置被“移动”到了最上面。这个过程就叫做提升。
换句话说，先有蛋（声明）后有鸡（赋值）。
只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码的顺序，会造成非常严重的破坏。
每个作用域都会进行提升操作。
即使是具名的函数表达式，名称标识符在赋值之前也无法再所在作用域中使用。
## 4.3 函数优先 ？？？
函数先提升，然后是变量。
## 4.4 小结
声明本身会提升，而包括函数表达式的赋值在内的赋值操作并不会提升。
要避免重复声明，特别是当普通的var声明和函数声明混在一起的时候。

# 第五章 作用域闭包？
## 5.1 启示
## 5.2 实质问题？P44
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
- function foo(){
    var a=2;
    function bar(){
        console.log(a);//2
    }
    bar();
}
foo();
- function foo(){
    var a=2;
    function bar(){
        console.log(a);
    }
    return bar;
}
var baz=foo();
baz();//2
- function foo(){
    var a=2;
    function baz(){
        console.log(a);
    }
    bar(baz);
}
function bar(fn){
    fn();//这就是闭包！
}
- var fn;
function foo(){
    var a=2;
    function baz(){
        console.log(a);
    }
    fn=baz;//将baz分配给全局变量
}
function bar(){
    fn();//这就是闭包！
}
foo();
bar();//2
## 5.3 现在我懂了？
只要使用了回调函数，实际上就是在使用闭包。
## 5.4 循环和闭包
for(var i=1;i<=5;i++){
    (function (j){
        setTimeout(function timer(){
            console.log(j);
        },j#1000);
    })(i);
}
- 重返块作用域
我们使用IIFE时在每次迭代时都创建一个新的作用域，换句话说，每次迭代我们都需要一个块作用域。let声明可以用来劫持一个块作用域，并且在这个块作用域中声明一个变量。
本质上，这是将一个块转换成一个可以被关闭的作用域。
function(let i=0;i<=5;i++){
    setTimeout(function timer(){
        console.log(i);
    },i*1000);
}
## 5.5 模块 P52
模块模式有两个必要条件：
1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。
一个具有函数属性的对象本身并不是真正的模块。
### 5.5.1 现代的模块机制 P54
### 5.5.2 未来的模块机制
- import可以将一个模块的有个或多个API导入到当前作用域中，并分别绑定在一个变量上。
- module会将整个模块的API导入并绑定到一个变量上。
- export会将当前模块的一个标识符（变量、函数）导出为公共API。
## 5.6 小结
当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这是就产生了闭包。

# 附录A 动态作用域
词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是他的定义过程发生在代码的书写阶段(假设你没有使用eval()或with)
动态作用域似乎暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式。
- function foo(){
    console.log(a);//2
}
function bar(){
    var a=3;
    foo();
}
var a=2;
bar();
词法作用域让foo()中的a通过RSH引用到了全局作用域中的a,因此输出的是2。
而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。
因此，如果JavaScript具有动态作用域，理论上，下面的代码中foo()在执行时会输出3：
-function foo(){
    console.log(a);//3
}
function bar(){
    var a=3;
    foo();
}
var a=2;
bar();
为什么？因为当foo()无法找到a的变量引用时，会顺着调用栈再调用foo()的地方查找a,而不是在嵌套的词法作用域链中向上查找。
实际上JavaScript只具有词法作用域，不具有动态作用域。this机制很像动态作用域！this关注函数如何调用。
# 附录B 块作用域的替代方案
with和catch分句就是块作用域的两个小例子。
let的引入，使代码拥有了创建完整、不受约束的块作用域的能力。
{
    let a=2;
    console.log(a);//2
}
console.log(a);//ReferenceError
ES6环境中可以正常工作，es6之前用catch：
try{throw 2;}catch(a){
    console.log(a);//2
}
console.log(a);//ReferencrError
catch分句具有块作用域，所以在es6之前可以作为替代方案。
## B.1 Traceur
Traceur项目用来将ES6代码转换为兼容ES6之前的环境（大部分是ES5，但不是全部）。
{
    try{
        throw undefined;
    }catch(a){
        a=2;
        console.log(a);
    }
}
console.log(a);
## B.2 隐式和显式作用域 P62
let作用域或let(显式)声明（对比前面的let定义）。
- let (a=2){
    console.log(a);//2
}
console.log(a);//ReferenceError
- {
    let a=2;
    console.log(a);
}
console.log(a);//ReferenceError
let-er 构建时的代码转换器：找到let声明并对其进行转换。
## B.3 性能
try/catch的性能问题
# 附录C this词法
ES6添加了一个特殊的语法形式用于函数声明，叫做箭头函数。
var foo=a=>{
    console.log(a);
};
foo(2);//2
var self=this;使用词法作用域。
箭头函数在涉及this绑定时的行为和普通函数的行为完全不一致。
# 附录D 致谢（不重要）

